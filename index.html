<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day/Night World Map</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #ffffff;
            color: #333333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }
        
        h1 {
            margin-bottom: 20px;
        }
        
        .map-container {
            position: relative;
            display: inline-block;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            border: 1px solid #e0e0e0;
        }
        
        #worldMap {
            display: block;
            width: 1000px;
            height: 500px;
            filter: brightness(1.5);
            /*filter: grayscale();*/
        }
        
        #mapCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 1000px;
            height: 500px;
            pointer-events: none;
        }
        
        .info {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            display: inline-block;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .legend {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        
        /* Minimal mode styles */
        .minimal-mode h1,
        .minimal-mode .legend {
            display: none;
        }
        
        .minimal-mode body {
            padding: 0;
            margin: 0;
        }
        
        .minimal-mode .container {
            margin: 0;
            max-width: none;
            text-align: left;
            height: calc(100vh - 60px);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .minimal-mode .map-container {
            border-radius: 0;
            border: none;
            box-shadow: none;
            width: 100%;
            height: 100%;
            max-width: calc((100vh - 60px) * 2); /* Maintain 2:1 aspect ratio */
            max-height: 50vw; /* If width is constrained, maintain ratio */
            overflow: hidden; /* Hide content beyond edges */
            aspect-ratio: 2 / 1;
        }
        
        .minimal-mode #worldMap,
        .minimal-mode #mapCanvas {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensure image fills container properly */
        }
        
        /* Info box in minimal mode */
        .minimal-mode .info {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            margin: 0;
            padding: 10px 20px;
            background-color: rgba(248, 249, 250, 0.95);
            border: none;
            border-top: 1px solid #e0e0e0;
            border-radius: 0;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            height: 40px;
        }
        
        .minimal-mode .info > div {
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Real-Time Day/Night World Map</h1>
        <div class="map-container">
            <img id="worldMap" src="BlankMap-Equirectangular.svg" alt="World Map">
            <canvas id="mapCanvas" width="1000" height="500"></canvas>
        </div>
        
        <div class="info">
            <div id="currentTime"></div>
            <div id="sunPosition"></div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: rgba(0,0,50,0.7);"></div>
                <span>Night</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: rgba(0,0,50,0.4);"></div>
                <span>Twilight</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: rgba(255,255,255,0.3);"></div>
                <span>Terminator Line</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #FFD700;"></div>
                <span>☀ Sun Position</span>
            </div>
        </div>
    </div>

    <script>
        // Check for minimal mode URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const hashParams = new URLSearchParams(window.location.hash.substring(1));
        const isMinimal = urlParams.has('minimal') || hashParams.has('minimal') || 
                         window.location.search.includes('minimal') || 
                         window.location.hash.includes('minimal');
        
        // Apply minimal mode if requested
        if (isMinimal) {
            document.documentElement.classList.add('minimal-mode');
        }
        
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        
        // Function to update canvas size
        function updateCanvasSize() {
            if (isMinimal) {
                // In minimal mode, size canvas to fill container
                const container = document.querySelector('.map-container');
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            } else {
                // Normal mode - fixed size
                canvas.width = 1000;
                canvas.height = 500;
            }
        }
        
        // Initial canvas size setup
        updateCanvasSize();
        
        // Update canvas size on window resize in minimal mode
        if (isMinimal) {
            window.addEventListener('resize', () => {
                updateCanvasSize();
                drawMap(); // Redraw after resize
            });
        }
        
        // Convert latitude/longitude to canvas coordinates (Mercator projection)
        function latLngToPixel(lat, lng) {
            const x = (lng + 180) * (canvas.width / 360);
            const latRad = lat * Math.PI / 180;
            const mercatorN = Math.log(Math.tan((Math.PI / 4) + (latRad / 2)));
            const y = (canvas.height / 2) - (canvas.width * mercatorN / (2 * Math.PI));
            return { x, y };
        }

        // Calculate solar position based on date and time
        function getSolarPosition(date) {
            // Simple, reliable approach
            const dayOfYear = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 864e5);
            const hours = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
            
            // Solar declination (simple but accurate enough)
            const declination = -23.45 * Math.cos(2 * Math.PI * (dayOfYear + 10) / 365.25);
            
            // Solar longitude: where sun is directly overhead
            // At UTC noon (12:00), sun is at longitude 0°
            // Sun moves 15° west per hour (360° / 24 hours)
            const sunLongitude = -(hours - 12) * 15;
            
            return {
                lat: declination,
                lng: sunLongitude > 180 ? sunLongitude - 360 : sunLongitude < -180 ? sunLongitude + 360 : sunLongitude
            };
        }


        // Calculate solar elevation angle
        function getSolarElevation(lat, lng, sunLat, sunLng) {
            const latRad = lat * Math.PI / 180;
            const sunLatRad = sunLat * Math.PI / 180;
            const lngDiff = (lng - sunLng) * Math.PI / 180;
            
            const elevation = Math.asin(
                Math.sin(latRad) * Math.sin(sunLatRad) +
                Math.cos(latRad) * Math.cos(sunLatRad) * Math.cos(lngDiff)
            ) * 180 / Math.PI;
            
            return elevation;
        }

        // Calculate day/night terminator line points
        function getTerminatorPoints(sunPos) {
            const points = [];
            for (let lng = -180; lng <= 180; lng += 2) {
                // Find latitude where solar elevation equals 0
                for (let lat = -90; lat <= 90; lat += 1) {
                    const elevation = getSolarElevation(lat, lng, sunPos.lat, sunPos.lng);
                    
                    // Check if this point is close to the terminator (elevation ≈ 0)
                    if (Math.abs(elevation) < 0.5) {
                        const pixel = latLngToPixel(lat, lng);
                        if (pixel.y >= 0 && pixel.y <= canvas.height) {
                            points.push(pixel);
                        }
                        break; // Found terminator for this longitude
                    }
                }
            }
            return points;
        }

        // Main drawing function
        function drawMap() {
            const now = new Date();
            const sunPos = getSolarPosition(now);
            
            // Clear canvas (make transparent for overlay)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw night overlay with smooth gradient using optimized approach
            const pixelSize = 2; // Balanced performance and quality
            
            // Use image data for smooth pixel manipulation
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let x = 0; x < canvas.width; x += pixelSize) {
                for (let y = 0; y < canvas.height; y += pixelSize) {
                    // Convert pixel back to lat/lng
                    const lng = (x / canvas.width) * 360 - 180;
                    const mercatorN = (canvas.height / 2 - y) * 2 * Math.PI / canvas.width;
                    const lat = Math.atan(Math.sinh(mercatorN)) * 180 / Math.PI;
                    
                    // Skip invalid latitudes
                    if (lat > 85 || lat < -85) continue;
                    
                    const elevation = getSolarElevation(lat, lng, sunPos.lat, sunPos.lng);
                    
                    // Create smooth gradient with tighter thresholds
                    let alpha = 0;
                    if (elevation < -12) {
                        alpha = 0.8; // Deep night
                    } else if (elevation < -6) {
                        // Astronomical twilight
                        const factor = (elevation + 12) / 6;
                        alpha = 0.8 - (0.2 * factor);
                    } else if (elevation < -1) {
                        // Nautical/civil twilight
                        const factor = (elevation + 6) / 5;
                        alpha = 0.6 - (0.4 * factor);
                    } else if (elevation < 0) {
                        // Very light twilight at horizon
                        const factor = (elevation + 1) / 1;
                        alpha = 0.2 - (0.2 * factor);
                    }
                    
                    // Apply to image data for smoother rendering
                    if (alpha > 0) {
                        for (let dx = 0; dx < pixelSize && x + dx < canvas.width; dx++) {
                            for (let dy = 0; dy < pixelSize && y + dy < canvas.height; dy++) {
                                const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                                data[idx] = 0;     // R
                                data[idx + 1] = 0; // G
                                data[idx + 2] = 30; // B
                                data[idx + 3] = Math.floor(alpha * 255*0.75); // A
                            }
                        }
                    }
                }
            }
            
            // Render the image data
            ctx.putImageData(imageData, 0, 0);
            
            // Draw terminator line
            const terminatorPoints = getTerminatorPoints(sunPos);
            if (terminatorPoints.length > 1) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                terminatorPoints.forEach((point, i) => {
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke();
            }
            
            // Draw sun position
            const sunPixel = latLngToPixel(sunPos.lat, sunPos.lng);
            if (sunPixel.y >= 0 && sunPixel.y <= canvas.height) {
                // Sun glow
                const gradient = ctx.createRadialGradient(sunPixel.x, sunPixel.y, 0, sunPixel.x, sunPixel.y, 20);
                gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(sunPixel.x, sunPixel.y, 20, 0, 2 * Math.PI);
                ctx.fill();
                
                // Sun core
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(sunPixel.x, sunPixel.y, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            
            // Update info display
            document.getElementById('currentTime').textContent = 
                `Current UTC Time: ${now.toUTCString()}`;
            document.getElementById('sunPosition').textContent = 
                `Sun Position: ${sunPos.lat.toFixed(1)}°, ${sunPos.lng.toFixed(1)}°`;
        }

        // Initial draw and set up auto-refresh
        drawMap();
        setInterval(drawMap, 60000); // Update every minute
    </script>
</body>
</html>